<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>vampire`blogs</title>
  
  
  <link href="https://liuheng0315.github.io/atom.xml" rel="self"/>
  
  <link href="https://liuheng0315.github.io/"/>
  <updated>2023-04-20T14:25:07.284Z</updated>
  <id>https://liuheng0315.github.io/</id>
  
  <author>
    <name>冬遇</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode-218. 天际线问题</title>
    <link href="https://liuheng0315.github.io/2023/04/20/leetcode/leetcode-218-%E5%A4%A9%E9%99%85%E7%BA%BF%E9%97%AE%E9%A2%98/"/>
    <id>https://liuheng0315.github.io/2023/04/20/leetcode/leetcode-218-%E5%A4%A9%E9%99%85%E7%BA%BF%E9%97%AE%E9%A2%98/</id>
    <published>2023-04-20T14:24:14.000Z</published>
    <updated>2023-04-20T14:25:07.284Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode.cn/problems/the-skyline-problem/">leetcode-218. 天际线问题</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; getSkyline(<span class="keyword">int</span>[][] buildings) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(buildings == <span class="keyword">null</span> || buildings.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 采用扫描线方案解决</span></span><br><span class="line">        <span class="comment">// 定义一个存放最大值的优先队列</span></span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(buildings.length, (o1,o2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> height1 = o1[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> height2 = o2[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">// 倒序 最高排第一</span></span><br><span class="line">            <span class="keyword">return</span> height2 - height1;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义扫描线</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, List&lt;<span class="keyword">int</span>[]&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数据读入队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] arr : buildings)&#123;</span><br><span class="line">            <span class="keyword">int</span> x1 = arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> x2 = arr[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> h = arr[<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span>(!list.contains(x1))&#123;</span><br><span class="line">                list.add(x1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!list.contains(x2))&#123;</span><br><span class="line">                list.add(x2);</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;<span class="keyword">int</span>[]&gt; list1 = map.getOrDefault(x1, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            list1.add(arr);</span><br><span class="line">            map.put(x1, list1);</span><br><span class="line"></span><br><span class="line">            List&lt;<span class="keyword">int</span>[]&gt; list2 = map.getOrDefault(x2, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            list2.add(arr);</span><br><span class="line">            map.put(x2, list2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 前一个点的高度</span></span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历扫描线</span></span><br><span class="line">        <span class="keyword">for</span>(Integer x : list)&#123;</span><br><span class="line">            List&lt;<span class="keyword">int</span>[]&gt; arrList = map.get(x);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] arr : arrList)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[<span class="number">0</span>] == x)&#123;</span><br><span class="line">                    <span class="comment">// 加入队列</span></span><br><span class="line">                    queue.offer(arr);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[<span class="number">1</span>] == x)&#123;</span><br><span class="line">                    <span class="comment">// 移除队列</span></span><br><span class="line">                    queue.remove(arr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(queue.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 队列已经全部移除</span></span><br><span class="line">                List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                ans.add(x);</span><br><span class="line">                ans.add(<span class="number">0</span>);</span><br><span class="line">                res.add(ans);</span><br><span class="line">                last = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此时队列中的最大值</span></span><br><span class="line">            <span class="keyword">int</span>[] p = queue.peek();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(p[<span class="number">2</span>] != last)&#123;</span><br><span class="line"></span><br><span class="line">                last = p[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">                List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                ans.add(x);</span><br><span class="line">                ans.add(p[<span class="number">2</span>]);</span><br><span class="line">                res.add(ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-297. 二叉树的序列化与反序列化</title>
    <link href="https://liuheng0315.github.io/2023/04/12/leetcode/leetcode-297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://liuheng0315.github.io/2023/04/12/leetcode/leetcode-297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2023-04-11T16:10:47.000Z</published>
    <updated>2023-04-11T16:11:33.233Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">leetcode-297. 二叉树的序列化与反序列化</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 宽度优先遍历</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 队列不为空,取出队头数据</span></span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">                 list.add(<span class="keyword">null</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               list.add(node.val); </span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data == <span class="keyword">null</span> || data.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String str = data.substring(<span class="number">1</span>, data.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] arr = str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s : arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="string">&quot;null&quot;</span>.equals(s.trim()))&#123;</span><br><span class="line">                list.add(Integer.valueOf(s.trim()));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                list.add(<span class="keyword">null</span>);</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        Integer val = list.get(cur++);</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cur == list.size() - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Integer leftVal = list.get(cur++);</span><br><span class="line">            TreeNode left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(leftVal != <span class="keyword">null</span>)&#123;</span><br><span class="line">                left = <span class="keyword">new</span> TreeNode(leftVal);</span><br><span class="line">            &#125;</span><br><span class="line">            node.left = left;</span><br><span class="line">            queue.offer(left);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cur == list.size() - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Integer rightVal = list.get(cur++);</span><br><span class="line">            TreeNode right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(rightVal != <span class="keyword">null</span>)&#123;</span><br><span class="line">                right = <span class="keyword">new</span> TreeNode(rightVal);</span><br><span class="line">            &#125;</span><br><span class="line">            node.right = right;</span><br><span class="line">            queue.offer(right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser = new Codec();</span></span><br><span class="line"><span class="comment">// Codec deser = new Codec();</span></span><br><span class="line"><span class="comment">// TreeNode ans = deser.deserialize(ser.serialize(root));</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-230. 二叉搜索树中第K小的元素</title>
    <link href="https://liuheng0315.github.io/2023/04/12/leetcode/leetcode-230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>https://liuheng0315.github.io/2023/04/12/leetcode/leetcode-230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</id>
    <published>2023-04-11T16:05:15.000Z</published>
    <updated>2023-04-11T16:06:11.356Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/">leetcode-230. 二叉搜索树中第K小的元素</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, (o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> o1 - o2;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        dfs(root, queue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = queue.poll();</span><br><span class="line">            k--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">                res = v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( k &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root,  Queue&lt;Integer&gt; queue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(root.val);</span><br><span class="line"></span><br><span class="line">        dfs(root.left, queue);</span><br><span class="line">        dfs(root.right, queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-454. 四数相加 II</title>
    <link href="https://liuheng0315.github.io/2023/04/12/leetcode/leetcode-454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0-II/"/>
    <id>https://liuheng0315.github.io/2023/04/12/leetcode/leetcode-454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0-II/</id>
    <published>2023-04-11T16:02:32.000Z</published>
    <updated>2023-04-11T16:03:37.673Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode.cn/problems/4sum-ii/">leetcode-454. 四数相加 II</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span>[] nums3, <span class="keyword">int</span>[] nums4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分治思想</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map1 = merge(nums1, nums2);</span><br><span class="line">        Map&lt;Integer, Integer&gt; map2 = merge(nums3, nums4);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : map1.entrySet())&#123;</span><br><span class="line">            <span class="comment">// 遍历整个集合</span></span><br><span class="line">            Integer key = entry.getKey();</span><br><span class="line">            Integer value1 = entry.getValue();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(map2.containsKey((<span class="number">0</span> - key)))&#123;</span><br><span class="line">                Integer value2 = map2.get((<span class="number">0</span> - key));</span><br><span class="line">                res += value1 * value2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Integer, Integer&gt; <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span></span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums2.length; j++)&#123;</span><br><span class="line">                Integer value = nums1[i] + nums2[j];</span><br><span class="line">                map.put(value, map.getOrDefault(value, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-171. Excel 表列序号</title>
    <link href="https://liuheng0315.github.io/2023/04/04/leetcode/leetcode-171-Excel-%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7/"/>
    <id>https://liuheng0315.github.io/2023/04/04/leetcode/leetcode-171-Excel-%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7/</id>
    <published>2023-04-04T15:29:08.000Z</published>
    <updated>2023-04-04T15:30:02.825Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode.cn/problems/excel-sheet-column-number/description/">171. Excel 表列序号</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String columnTitle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(columnTitle == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = columnTitle.length();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大A的为65</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnTitle.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> x = columnTitle.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> k = Integer.valueOf(x) - Integer.valueOf(<span class="string">&#x27;A&#x27;</span>) + <span class="number">1</span> ;</span><br><span class="line">            res += Math.pow(<span class="number">26</span>, n - i - <span class="number">1</span>) * k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-1971. 寻找图中是否存在路径</title>
    <link href="https://liuheng0315.github.io/2023/04/03/leetcode/leetcode-1971-%E5%AF%BB%E6%89%BE%E5%9B%BE%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%B7%AF%E5%BE%84/"/>
    <id>https://liuheng0315.github.io/2023/04/03/leetcode/leetcode-1971-%E5%AF%BB%E6%89%BE%E5%9B%BE%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%B7%AF%E5%BE%84/</id>
    <published>2023-04-02T16:23:29.000Z</published>
    <updated>2023-04-03T14:17:32.361Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode.cn/problems/find-if-path-exists-in-graph/description/">leetcode-1971. 寻找图中是否存在路径</a></p><h2 id="解法一深度优先搜索"><a class="markdownIt-Anchor" href="#解法一深度优先搜索"></a> 解法一：深度优先搜索</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPath</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges, <span class="keyword">int</span> source, <span class="keyword">int</span> destination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(source == destination)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(edges.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深度优先搜索</span></span><br><span class="line">        <span class="comment">// 存放路径</span></span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = edges[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> b = edges[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(a))&#123;</span><br><span class="line">                map.get(a).add(b);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">                list.add(b);</span><br><span class="line">                map.put(a, list);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(b))&#123;</span><br><span class="line">                map.get(b).add(a);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">                list.add(a);</span><br><span class="line">                map.put(b, list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行深度优先搜索</span></span><br><span class="line">        <span class="comment">// set用来存放已经走过的点</span></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(map, set, source, destination);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(Map&lt;Integer, List&lt;Integer&gt;&gt; map, Set&lt;Integer&gt; set, <span class="keyword">int</span> source, <span class="keyword">int</span> destination)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(source))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; list = map.get(source);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(list.contains(destination))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(set.contains(source))&#123;</span><br><span class="line">            <span class="comment">// 该节点已被访问过</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录节点已经被遍历过</span></span><br><span class="line">        set.add(source);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(map, set, list.get(i), destination))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法二广度优先搜索"><a class="markdownIt-Anchor" href="#解法二广度优先搜索"></a> 解法二：广度优先搜索</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPath</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges, <span class="keyword">int</span> source, <span class="keyword">int</span> destination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(source == destination)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(edges.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 广度优先搜索</span></span><br><span class="line">        <span class="comment">// 存放路径</span></span><br><span class="line">        List&lt;Integer&gt;[] arr = <span class="keyword">new</span> List[n];</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="comment">// 初始化存放路径的数组</span></span><br><span class="line">            arr[i] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = edges[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> b = edges[i][<span class="number">1</span>];</span><br><span class="line">            arr[a].add(b);</span><br><span class="line">            arr[b].add(a);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        queue.offer(source);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(queue.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            Integer t = queue.poll();</span><br><span class="line">            List&lt;Integer&gt; list = arr[t];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(visited[t])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            visited[t] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(t == destination)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">                Integer x = list.get(i);</span><br><span class="line">                <span class="keyword">if</span>(!visited[x])&#123;</span><br><span class="line">                    queue.offer(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> visited[destination];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法三并查集"><a class="markdownIt-Anchor" href="#解法三并查集"></a> 解法三：并查集</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPath</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges, <span class="keyword">int</span> source, <span class="keyword">int</span> destination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化并查集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] arr : edges)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> b = arr[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 并查集链接</span></span><br><span class="line">            union(parent, a, b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(find(parent, source) == find(parent, destination))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] parent, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[k] != k)&#123;</span><br><span class="line">            parent[k] = find(parent, parent[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] parent, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = find(parent, i);</span><br><span class="line">        <span class="keyword">int</span> y = find(parent, j);</span><br><span class="line">        <span class="keyword">if</span>(x != y)&#123;</span><br><span class="line">            parent[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot源码解析笔记</title>
    <link href="https://liuheng0315.github.io/2021/11/03/spring-boot/spring-boot%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/"/>
    <id>https://liuheng0315.github.io/2021/11/03/spring-boot/spring-boot%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/</id>
    <published>2021-11-03T11:58:39.000Z</published>
    <updated>2021-11-03T12:27:02.925Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="ques1springboot是如何进行自动配置的都把哪些组件进行了自动配置"><a class="markdownIt-Anchor" href="#ques1springboot是如何进行自动配置的都把哪些组件进行了自动配置"></a> 🐣Ques1:springboot是如何进行自动配置的，都把哪些组件进行了自动配置？</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="spring-boot" scheme="https://liuheng0315.github.io/categories/spring-boot/"/>
    
    
    <category term="springboot" scheme="https://liuheng0315.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-239. 滑动窗口最大值</title>
    <link href="https://liuheng0315.github.io/2021/09/01/leetcode/leetcode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>https://liuheng0315.github.io/2021/09/01/leetcode/leetcode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</id>
    <published>2021-09-01T10:27:30.000Z</published>
    <updated>2021-09-01T10:29:13.934Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="239-滑动窗口最大值"><a class="markdownIt-Anchor" href="#239-滑动窗口最大值"></a> <a href="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h4><p>优先队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 使用优先队列</span></span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;<span class="keyword">int</span>[]&gt;((o1, o2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(o2[<span class="number">0</span>] - o1[<span class="number">0</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(o2[<span class="number">0</span>] - o1[<span class="number">0</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o2[<span class="number">1</span>] - o1[<span class="number">1</span>] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将前k个数据先入队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans[<span class="number">0</span>] = queue.peek()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历剩下的数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; queue.peek()[<span class="number">1</span>] &lt; (i - k + <span class="number">1</span>))&#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[i], i&#125;);</span><br><span class="line">            ans[i-k+<span class="number">1</span>] = queue.peek()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双端队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n-k+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; nums[i] &gt; nums[queue.peekLast()])&#123;</span><br><span class="line">                queue.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offerLast(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans[<span class="number">0</span>] = nums[queue.peekFirst()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>((!queue.isEmpty()) &amp;&amp; nums[i] &gt; nums[queue.peekLast()])&#123;</span><br><span class="line">                queue.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>((!queue.isEmpty()) &amp;&amp; queue.peekFirst() &lt; i - k + <span class="number">1</span>)&#123;</span><br><span class="line">                queue.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            queue.offerLast(i);</span><br><span class="line">            ans[i-k+<span class="number">1</span>] = nums[queue.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>redis-geek-04-哨兵机制-主库挂了如何不间断服务</title>
    <link href="https://liuheng0315.github.io/2021/08/30/redis/redis-geek-04-%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6-%E4%B8%BB%E5%BA%93%E6%8C%82%E4%BA%86%E5%A6%82%E4%BD%95%E4%B8%8D%E9%97%B4%E6%96%AD%E6%9C%8D%E5%8A%A1/"/>
    <id>https://liuheng0315.github.io/2021/08/30/redis/redis-geek-04-%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6-%E4%B8%BB%E5%BA%93%E6%8C%82%E4%BA%86%E5%A6%82%E4%BD%95%E4%B8%8D%E9%97%B4%E6%96%AD%E6%9C%8D%E5%8A%A1/</id>
    <published>2021-08-30T09:30:42.000Z</published>
    <updated>2021-08-30T09:39:39.952Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="哨兵机制-主库挂了如何不间断服务"><a class="markdownIt-Anchor" href="#哨兵机制-主库挂了如何不间断服务"></a> 哨兵机制-主库挂了如何不间断服务</h2><h3 id="主观下线和客观下线"><a class="markdownIt-Anchor" href="#主观下线和客观下线"></a> 主观下线和客观下线</h3><p><strong>哨兵进程会使用ping命令检测它自己和主、从库的网络连接情况，来判断实例的状态</strong>，如果哨兵发现主库或从库对PING命令的响应超时了，那么，哨兵就会先把它标记为“主观下线”。 如果检测的是从库，那么，哨兵简单地把它标记为“主观下线”就⾏了，因为从库的下线影响⼀般不太⼤， 集群的对外服务不会间断。在判断主库是否下线时，不能由⼀个哨兵说了算，只有⼤多数的哨兵实例，都判断主库已经“主观下 线”了，主库才会被标记为“客观下线”，这个叫法也是表明主库下线成为⼀个客观事实了。这个判断原则 就是：少数服从多数。同时，这会进⼀步触发哨兵开始主从切换流程。</p><h3 id="如何选定新主库"><a class="markdownIt-Anchor" href="#如何选定新主库"></a> 如何选定新主库</h3><p>先从多个从库中筛选掉不在线的和网络连接状态较差的，然后<strong>从库的优先级、从库的复制进度以及从库的ID号</strong>进行打分</p><ul><li>第⼀轮：优先级最⾼的从库得分⾼。</li><li>第二轮：和旧主库同步程度最接近的从库得分高</li><li>第三轮：ID号越小的从库得分高</li></ul><p>Redis的哨兵机制⾃动完成了以下三⼤功能，从⽽实现了主从库的⾃动切换，可以降低Redis集群的运维开销：</p><ul><li>监控主库运⾏状态，并判断主库是否客观下线；</li><li>在主库客观下线后，选取新主库；</li><li>选出新主库后，通知从库和客⼾端。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="redis" scheme="https://liuheng0315.github.io/categories/redis/"/>
    
    
    <category term="redis" scheme="https://liuheng0315.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis-geek-03-AOF日志-宕机了如何避免数据丢失</title>
    <link href="https://liuheng0315.github.io/2021/08/27/redis/redis-geek-03-AOF%E6%97%A5%E5%BF%97-%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1/"/>
    <id>https://liuheng0315.github.io/2021/08/27/redis/redis-geek-03-AOF%E6%97%A5%E5%BF%97-%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1/</id>
    <published>2021-08-27T03:57:56.000Z</published>
    <updated>2021-08-30T09:31:03.019Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="aof日志-宕机了如何避免数据丢失"><a class="markdownIt-Anchor" href="#aof日志-宕机了如何避免数据丢失"></a> AOF日志-宕机了如何避免数据丢失</h2><p>AOF⽇志正好相反，它是写后⽇志，“写 后”的意思是Redis是先执⾏命令，把数据写⼊内存，然后才记录⽇志<br /><strong>好处：</strong></p><ol><li>为了避免额外的检查开销，Redis在向AOF⾥⾯记录⽇志的时候，并不会先去对这些命令进⾏语法检 查。所以，如果先记⽇志再执⾏命令的话，⽇志中就有可能记录了错误的命令，Redis在使⽤⽇志恢复数据 时，就可能会出错。⽽写后⽇志这种⽅式，就是先让系统执⾏命令，只有命令能执⾏成功，才会被记录到⽇志中，否则，系统就 会直接向客⼾端报错。所以，Redis使⽤写后⽇志这⼀⽅式的⼀⼤好处是，可以避免出现记录错误命令的情况。</li><li>它是在命令执⾏后才记录⽇志，所以不会阻塞当前写操作</li></ol><p><strong>潜在风险：</strong></p><ol><li>如果刚执⾏完⼀个命令，还没有来得及记⽇志就宕机了，那么这个命令和相应的数据就有丢失的⻛险。</li><li>AOF虽然避免了对当前命令的阻塞，但可能会给下⼀个操作带来阻塞⻛险。这是因为，AOF⽇志也是 在主线程中执⾏的，如果在把⽇志⽂件写⼊磁盘时，磁盘写压⼒⼤，就会导致写盘很慢，进⽽导致后续的操作也⽆法执⾏了。</li></ol><p><strong>三种写策略</strong></p><p>AOF机制给我们提供了三个选择，也就是AOF配置项appendfsync的三个可选值</p><ul><li><strong>Always</strong>：同步写回：每个写命令执⾏完，⽴⻢同步地将⽇志写回磁盘；</li><li><strong>Everysec</strong>：每秒写回：每个写命令执⾏完，只是先把⽇志写到AOF⽂件的内存缓冲区，每隔⼀秒把缓冲 区中的内容写⼊磁盘；</li><li><strong>No</strong>：操作系统控制的写回：每个写命令执⾏完，只是先把⽇志写到AOF⽂件的内存缓冲区，由操作系统 决定何时将缓冲区内容写回磁盘。</li></ul><img src="/images/image-20210827134953513.png" alt="image-20210827134953513" style="zoom:50%;" /><h3 id="aof文件过大导致性能问题"><a class="markdownIt-Anchor" href="#aof文件过大导致性能问题"></a> AOF文件过大导致性能问题</h3><p>AOF文件“性能问题”，主要在于以下三个⽅⾯：</p><ol><li>⽂件系统本⾝对⽂件⼤⼩有限制，⽆法保存过⼤的⽂ 件；</li><li>如果⽂件太⼤，之后再往⾥⾯追加命令记录的话，效率也会变低；</li><li>如果发⽣宕机，AOF中 记录的命令要⼀个个被重新执⾏，⽤于故障恢复，如果⽇志⽂件太⼤，整个恢复过程就会⾮常缓慢，这就会 影响到Redis的正常使⽤。</li></ol><h3 id="aof文件日志太大了怎么办"><a class="markdownIt-Anchor" href="#aof文件日志太大了怎么办"></a> AOF文件日志太大了怎么办</h3><p>AOF重写机制就是在<strong>重写</strong>时，Redis<strong>根据数据库的现状创建⼀个新的AOF⽂</strong>件，也就是说，读取数据库中的所有键值对，然后对每⼀个键值对⽤⼀条命令记录它的写⼊</p><p>虽然AOF重写后，⽇志⽂件会缩⼩，但是，要把整个数据库的最新数据的操作⽇志都写回磁盘，仍然 是⼀个⾮常耗时的过程。这时，我们就要继续关注另⼀个问题了：重写会不会阻塞主线程？</p><h3 id="aof重写会阻塞主线程吗"><a class="markdownIt-Anchor" href="#aof重写会阻塞主线程吗"></a> AOF重写会阻塞主线程吗？</h3><p>和AOF⽇志由主线程写回不同，重写过程是由后台线程bgrewriteaof来完成的，这也是为了避免阻塞主线 程，导致数据库性能下降。把重写的过程总结为“<strong>⼀个拷⻉，两处⽇志</strong>”</p><p>“<strong>⼀个拷⻉</strong>”就是指，每次执⾏重写时，主线程fork出后台的bgrewriteaof⼦进程。此时，fork会把主线程 的内存拷⻉⼀份给bgrewriteaof⼦进程，这⾥⾯就<strong>包含了数据库的最新数据</strong>。然后，bgrewriteaof⼦进程就可以在不影响主线程的情况下，逐⼀把拷⻉的数据写成操作，记⼊重写⽇志。<br />“<strong>两处⽇志</strong>”⼜是什么呢？因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第⼀处⽇志就是指正在使⽤的AOF⽇志，Redis会<strong>把这个操作写到它的缓冲区</strong>。这样⼀来，即使宕机了，这个AOF⽇志的操作仍然是⻬全的，可以⽤于恢复。 ⽽第⼆处⽇志，就是指新的AOF重写⽇志。这个操作也会被写到重写⽇志的缓冲区。这样，重写⽇志也不会丢失最新的操作。等到拷⻉数据的所有操作记录重写完成后，重写⽇志记录的这些最新操作也会写⼊新的 AOF⽂件，以保证数据库最新状态的记录。此时，我们就可以⽤新的AOF⽂件替代旧⽂件了。</p><img src="/images/image-20210827142154245.png" alt="image-20210827142154245" style="zoom:50%;" /><p>每次AOF重写时，Redis会先执⾏⼀个内存拷⻉，⽤于重写；然后使⽤两个⽇志保证在重写过程中，新写⼊的数据不会丢失。⽽且因为Redis采⽤额外的线程进⾏数据重写，所以，这个过程并不会阻塞主线程。</p><h3 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题：</h3><ol><li>AOF⽇志重写的时候，是由bgrewriteaof⼦进程来完成的，不⽤主线程参与，我们今天说的⾮阻塞也是指 ⼦进程的执⾏不阻塞主线程。但是，你觉得，这个重写过程有没有其他潜在的阻塞⻛险呢？如果有的 话，会在哪⾥阻塞？</li><li><ol start="2"><li>AOF重写也有⼀个重写⽇志，为什么它不共享使⽤AOF本⾝的⽇志呢？</li></ol></li></ol><p>问题1回答：如果⼦进程写⼊事件过⻓，并且这段事件，会导致AOF重写⽇志，积累过多，当新的AOF⽂件完成后，还是需要写⼊⼤量AOF重写⽇志⾥的内容，可能会导致阻塞。</p><p>问题2回答：⽗⼦两个进程本来就没有需要竞争的数据，⽼师所指的两个⽇志应该是“AOF缓冲区”和&quot;AOF重写缓冲区&quot;，⽽不是磁盘上的AOF⽂件，之所有另外有⼀个&quot;AOF重写缓冲区&quot;，是因为重写期间，主进程AOF还在继续⼯作，还是会同步到旧的AOF⽂件中，同步成功后，“AOF缓冲区”会被清除，会被清除，会被清除！</p><h2 id="rdb-内存快照"><a class="markdownIt-Anchor" href="#rdb-内存快照"></a> RDB-内存快照</h2><p>Redis提供了两个命令来⽣成RDB⽂件，分别是save和bgsave。</p><ul><li>save：在主线程中执⾏，会导致阻塞；</li><li>bgsave：创建⼀个⼦进程，专⻔⽤于写⼊RDB⽂件，避免了主线程的阻塞，这也是Redis RDB⽂件⽣成的 默认配置。</li></ul><p>为了快照⽽暂停写操作，肯定是不能接受的，Redis会借助操作系统提供的写时复制技术 （Copy-On-Write, COW），在执⾏快照的同时，正常处理写操作。 简单来说，bgsave⼦进程是由主线程fork⽣成的，可以共享主线程的所有内存数据。bgsave⼦进程运⾏后，开始读取主线程的内存数据，并把它们写⼊RDB⽂件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="redis" scheme="https://liuheng0315.github.io/categories/redis/"/>
    
    
    <category term="redis" scheme="https://liuheng0315.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>zulu-笔记01</title>
    <link href="https://liuheng0315.github.io/2021/08/26/springCloud/ribbon/zulu-%E7%AC%94%E8%AE%B001/"/>
    <id>https://liuheng0315.github.io/2021/08/26/springCloud/ribbon/zulu-%E7%AC%94%E8%AE%B001/</id>
    <published>2021-08-26T00:27:28.000Z</published>
    <updated>2021-08-26T02:09:49.429Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="spring cloud" scheme="https://liuheng0315.github.io/categories/spring-cloud/"/>
    
    
    <category term="zuul" scheme="https://liuheng0315.github.io/tags/zuul/"/>
    
  </entry>
  
  <entry>
    <title>redis-geek-02-高性能IO模型-为什么单线程redis那么快</title>
    <link href="https://liuheng0315.github.io/2021/08/20/redis/redis-geek-02-%E9%AB%98%E6%80%A7%E8%83%BDIO%E6%A8%A1%E5%9E%8B-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8Bredis%E9%82%A3%E4%B9%88%E5%BF%AB/"/>
    <id>https://liuheng0315.github.io/2021/08/20/redis/redis-geek-02-%E9%AB%98%E6%80%A7%E8%83%BDIO%E6%A8%A1%E5%9E%8B-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8Bredis%E9%82%A3%E4%B9%88%E5%BF%AB/</id>
    <published>2021-08-20T14:39:48.000Z</published>
    <updated>2021-08-27T03:58:19.406Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="为什么单线程redis那么快"><a class="markdownIt-Anchor" href="#为什么单线程redis那么快"></a> 为什么单线程redis那么快</h2><p>我们通常说redis是单线程的，<strong>主要指redis的网络IO和键值对读写是由一个线程完成的，这也是redis对外提供键值存储服务的主要流程</strong>，但Redis的其他功能，⽐如持久化、 异步删除、集群数据同步等，其实是由额外的线程执⾏的</p><h3 id="redis的单线程设计机制以及多路复用机制"><a class="markdownIt-Anchor" href="#redis的单线程设计机制以及多路复用机制"></a> Redis的单线程设计机制以及多路复⽤机制</h3><h4 id="redis为什么要用单线程"><a class="markdownIt-Anchor" href="#redis为什么要用单线程"></a> redis为什么要用单线程？</h4><h5 id="多线程的开销"><a class="markdownIt-Anchor" href="#多线程的开销"></a> 多线程的开销</h5><p>多线程编程面临共享资源并发访问控制问题，⼀个关键的瓶颈在于，系统中通常会存在被多线程同时访问的共享资源，⽐如⼀个共享的数据结构。当有多个线程要修改这个共享资源时，为了保证共享资源的正确性，就需要有额外的机制进⾏保证，⽽这个额外的机制，就会带来额外的开销。</p><h5 id="redis为什么这么快"><a class="markdownIt-Anchor" href="#redis为什么这么快"></a> redis为什么这么快</h5><ol><li><p>redis的大部分操作在内存中完成，再加上采用了高效的数据结构例如哈希表和跳表</p></li><li><p>redis采用了<strong>多路复用机制</strong>，使其在⽹络IO操作中能并发处理⼤量的客⼾端请求，实现⾼吞吐率。</p></li></ol><h5 id="基于多路复用的高性能io模型"><a class="markdownIt-Anchor" href="#基于多路复用的高性能io模型"></a> 基于多路复用的高性能IO模型</h5><p>在redis只运行单线程的情况下，<strong>该机制允许内核中，同时存在多个监听套接字和已连接套接字</strong>，内核会一直监听这些套接字上的连接请求和数据请求，一旦请求到达，便会交给redis线程处理，这就实现了一个redis线程处理多个IO流的效果</p><img src="/images/image-20210827112243828.png" alt="image-20210827112243828" style="zoom:50%;" /><p>为了在请求到达时能通知到Redis线程，select/epoll提供了<strong>基于事件的回调机制，针对不同的事件调用相应的处理函数</strong>，</p><p>回调机制是怎么⼯作的呢？其实，select/epoll⼀旦监测到FD上有请求到达时，就会触发相应的事件。这些事件会被放进⼀个事件队列，Redis单线程对该事件队列不断进⾏处理。这样⼀来，Redis⽆需⼀直轮询是否有请求实际发⽣，这就可以避免造成CPU资源浪费。同时Redis在对事件队列中的事件进⾏处理时， 会调⽤相应的处理函数，这就实现了基于事件的回调。因为Redis⼀直在对事件队列进⾏处理，所以能及时响应客⼾端请求，提升Redis的响应性能。</p><h3 id="redis单线程处理io请求性能瓶颈主要包括2个方面"><a class="markdownIt-Anchor" href="#redis单线程处理io请求性能瓶颈主要包括2个方面"></a> Redis单线程处理IO请求性能瓶颈主要包括2个⽅⾯：</h3><p><strong>1、任意⼀个请求在server中⼀旦发⽣耗时，都会影响整个server的性能，也就是说后⾯的请求都要等前⾯这个耗时请求处理完成，⾃⼰才能被处理到。耗时的操作包括以下⼏种：</strong></p><ul><li><p>a、操作bigkey：写⼊⼀个bigkey在分配内存时需要消耗更多的时间，同样删除bigkey释放内存同样会产⽣耗时；</p></li><li><p>b、使⽤复杂度过⾼的命令：例如SORT/SUNION/ZUNIONSTORE，或者O(N)命令，但是N很⼤，例如lrange key 0 -1⼀次查询全量数据；</p></li><li><p>c、⼤量key集中过期：Redis的过期机制也是在主线程中执⾏的，⼤量key集中过期会导致处理⼀个请求时，耗时都在删除过期key，耗时变⻓；</p></li><li><p>d、淘汰策略：淘汰策略也是在主线程执⾏的，当内存超过Redis内存上限后，每次写⼊都需要淘汰⼀些key，也会造成耗时变⻓；</p></li><li><p>e、AOF刷盘开启always机制：每次写⼊都需要把这个操作刷到磁盘，写磁盘的速度远⽐写内存慢，会拖慢Redis的性能；</p></li><li><p>f、主从全量同步⽣成RDB：虽然采⽤fork⼦进程⽣成数据快照，但fork这⼀瞬间也是会阻塞整个线程的， 实例越⼤，阻塞时间越久；</p></li></ul><p><strong>2、并发量⾮常⼤时，单线程读写客⼾端IO数据存在性能瓶颈，虽然采⽤IO多路复⽤机制，但是读写客⼾端数据依旧是同步IO，只能单线程依次读取客⼾端的数据，⽆法利⽤到CPU多核。</strong></p><p>针对问题1，⼀⽅⾯需要业务⼈员去规避，⼀⽅⾯Redis在4.0推出了lazy-free机制，把bigkey释放内存的耗时操作放在了异步线程中执⾏，降低对主线程的影响。</p><p>针对问题2，Redis在6.0推出了多线程，可以在⾼并发场景下利⽤CPU多核多线程读写客⼾端数据，进⼀步提升server性能，当然，只是针对客⼾端的读写是并⾏的，每个命令的真正操作依旧是单线程的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="redis" scheme="https://liuheng0315.github.io/categories/redis/"/>
    
    
    <category term="redis" scheme="https://liuheng0315.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis-geek-01-数据结构-一个键值数据库中包含哪些数据结构</title>
    <link href="https://liuheng0315.github.io/2021/08/18/redis/redis-geek-01-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84-%E4%B8%80%E4%B8%AA%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88/"/>
    <id>https://liuheng0315.github.io/2021/08/18/redis/redis-geek-01-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84-%E4%B8%80%E4%B8%AA%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88/</id>
    <published>2021-08-18T14:39:48.000Z</published>
    <updated>2021-08-26T11:23:28.191Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h2><h3 id="redis中包含的数据类型"><a class="markdownIt-Anchor" href="#redis中包含的数据类型"></a> Redis中包含的数据类型</h3><ul><li>String(字符串)、List(列表)、Hash(哈希)、Set(集合)、Sorted Set(有序集合)</li></ul><p><img src="/images/image-20210826101459882.png" alt="image-20210826101459882" /></p><h4 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题：</h4><ol><li><h4 id="这些数据结构都是值的底层实现键和值本身之间用什么结构组织"><a class="markdownIt-Anchor" href="#这些数据结构都是值的底层实现键和值本身之间用什么结构组织"></a> 这些数据结构都是值的底层实现，键和值本⾝之间⽤什么结构组织？</h4><ul><li><p>给哈希表2分配更⼤的空间，例如是当前哈希表1⼤⼩的两倍</p></li><li><p>把哈希表1中的数据重新映射并拷⻉到哈希表2中</p></li><li><p>释放哈希表1的空间</p></li></ul><p>这个过程看似简单，但是第⼆步涉及⼤量的数据拷⻉，如果⼀次性把哈希表1中的数据都迁移完，会造成Redis线程阻塞，⽆法服务其他请求。此时，Redis就⽆法快速访问数据了。 为了避免这个问题，Redis采⽤了<strong>渐进式rehash</strong>。</p><p>简单来说就是在第⼆步拷⻉数据时，Redis仍然正常处理客⼾端请求，每处理⼀个请求时，从哈希表1中的第⼀个索引位置开始，顺带着将这个索引位置上的所有entries拷⻉到哈希表2中；等处理下⼀个请求时，再顺带拷⻉哈希表1中的下⼀个索引位置的entries</p>  <img src="/images/image-20210826151935525.png" alt="image-20210826151935525" style="zoom:50%;" /></li><li><h4 id="为什么集合类型有那么多的底层结构它们都是怎么组织数据的都很快吗"><a class="markdownIt-Anchor" href="#为什么集合类型有那么多的底层结构它们都是怎么组织数据的都很快吗"></a> 为什么集合类型有那么多的底层结构，它们都是怎么组织数据的，都很快吗？</h4><p><strong>集合类型</strong>的底层数据结构主要有5种：<strong>整数数组、双向链表、哈希表、压缩列表和 跳表</strong>。</p><p><strong>压缩列表</strong>实际上类似于⼀个数组，数组中的每⼀个元素都对应保存⼀个数据。和数组不同的是，压缩列表在 表头有三个字段zlbytes、zltail和zllen，分别表⽰列表⻓度、列表尾的偏移量和列表中的entry个数；压缩列 表在表尾还有⼀个zlend，表⽰列表结束。</p><p><img src="/images/image-20210826154149881.png" alt="image-20210826154149881" /></p><p>在压缩列表中，如果我们要查找定位第⼀个元素和最后⼀个元素，可以通过表头三个字段的⻓度直接定位，复杂度是O(1)。⽽查找其他元素时，就没有这么⾼效了，只能逐个查找，此时的复杂度就是O(N)了</p><p><strong>跳表</strong>：有序链表只能逐⼀查找元素，导致操作起来⾮常缓慢，于是就出现了跳表。具体来说，跳表在链表的基础上，增加了多级索引，，通过索引位置的⼏个跳转，实现数据的快速定位，当数据量很⼤时，跳表的查找复杂度就是O(logN)。</p><img src="/images/image-20210826154704451.png" alt="image-20210826154704451" style="zoom:50%;" /><img src="/images/image-20210826155137460.png" alt="image-20210826155137460" style="zoom:40%;" /></li><li><h4 id="什么是简单动态字符串和常用的字符串是一回事吗"><a class="markdownIt-Anchor" href="#什么是简单动态字符串和常用的字符串是一回事吗"></a> 什么是简单动态字符串，和常⽤的字符串是⼀回事吗？</h4></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="redis" scheme="https://liuheng0315.github.io/categories/redis/"/>
    
    
    <category term="redis" scheme="https://liuheng0315.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-611. 有效三角形的个数</title>
    <link href="https://liuheng0315.github.io/2021/08/05/leetcode/leetcode-611-%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>https://liuheng0315.github.io/2021/08/05/leetcode/leetcode-611-%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2021-08-05T02:53:53.000Z</published>
    <updated>2021-08-05T02:54:29.821Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="611-有效三角形的个数"><a class="markdownIt-Anchor" href="#611-有效三角形的个数"></a> <a href="https://leetcode-cn.com/problems/valid-triangle-number/">611. 有效三角形的个数</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">triangleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 先排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 只需要a+b&gt;c即可</span></span><br><span class="line">                <span class="keyword">int</span> a = nums[i];</span><br><span class="line">                <span class="keyword">int</span> b = nums[j];</span><br><span class="line">                <span class="comment">// 二分查找j+1~n-1的范围内符合条件的数据,使用二分查找</span></span><br><span class="line">                <span class="keyword">int</span> l = j+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> r = n-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> k = j;</span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> ((a+b) &gt; nums[mid])&#123;</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                        k = mid;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        r = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += k - j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-21. 合并两个有序链表</title>
    <link href="https://liuheng0315.github.io/2021/08/03/leetcode/leetcode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>https://liuheng0315.github.io/2021/08/03/leetcode/leetcode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2021-08-03T12:30:46.000Z</published>
    <updated>2021-08-03T12:32:21.434Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="21-合并两个有序链表"><a class="markdownIt-Anchor" href="#21-合并两个有序链表"></a> <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以l1为主</span></span><br><span class="line">        ListNode cur1 = l1;</span><br><span class="line">        ListNode cur2 = l2;</span><br><span class="line">        ListNode root = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode cur = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="keyword">null</span> &amp;&amp; cur2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1.val &lt;= cur2.val)&#123;</span><br><span class="line">                cur.next = cur1;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = cur2;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历链表还没走完的部分</span></span><br><span class="line">        <span class="keyword">if</span>(cur1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            cur.next = cur1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cur2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            cur.next = cur2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-443. 压缩字符串</title>
    <link href="https://liuheng0315.github.io/2021/07/23/leetcode/leetcode-443-%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://liuheng0315.github.io/2021/07/23/leetcode/leetcode-443-%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2021-07-23T09:42:13.000Z</published>
    <updated>2021-07-23T09:42:50.165Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="443-压缩字符串"><a class="markdownIt-Anchor" href="#443-压缩字符串"></a> <a href="https://leetcode-cn.com/problems/string-compression/">443. 压缩字符串</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">char</span>[] chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = chars.length;</span><br><span class="line">        <span class="keyword">int</span>[] parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = chars[i];</span><br><span class="line">            <span class="keyword">if</span>(ch == chars[i-<span class="number">1</span>])&#123;</span><br><span class="line">                union(i, i-<span class="number">1</span>, parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        sb.append(chars[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> pre = find(i-<span class="number">1</span>, parent);</span><br><span class="line">            <span class="keyword">int</span> p1 = find(i, parent);</span><br><span class="line">            <span class="keyword">if</span>(pre == p1)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(count != <span class="number">1</span>)&#123;</span><br><span class="line">                    sb.append(count +<span class="string">&quot;&quot;</span>);</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(chars[i] +<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(count != <span class="number">1</span>)&#123;</span><br><span class="line">            sb.append(count +<span class="string">&quot;&quot;</span>);</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sb.length(); i++)&#123;</span><br><span class="line">            chars[i] = sb.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k != parent[k])&#123;</span><br><span class="line">            parent[k] = find(parent[k], parent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[] parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = find(i, parent);</span><br><span class="line">        <span class="keyword">int</span> y = find(j, parent);</span><br><span class="line">        <span class="keyword">if</span>(x != y)&#123;</span><br><span class="line">            parent[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-128. 最长连续序列</title>
    <link href="https://liuheng0315.github.io/2021/07/23/leetcode/leetcode-128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
    <id>https://liuheng0315.github.io/2021/07/23/leetcode/leetcode-128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</id>
    <published>2021-07-23T09:41:22.000Z</published>
    <updated>2021-07-23T09:41:50.280Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="128-最长连续序列"><a class="markdownIt-Anchor" href="#128-最长连续序列"></a> <a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 并查集</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        </span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化并查集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.get(num) == i)&#123;</span><br><span class="line">                <span class="comment">// 只处理map中包含的index的角标进行去重</span></span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(num-<span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="keyword">int</span> idx = map.get(num-<span class="number">1</span>);</span><br><span class="line">                    uion(i, idx, parent);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(num+<span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="keyword">int</span> idx = map.get(num+<span class="number">1</span>);</span><br><span class="line">                    uion(i, idx, parent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历查找并查集中最多的集合</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; countMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = find(i, parent);</span><br><span class="line">            <span class="keyword">int</span> count = countMap.getOrDefault(p, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            countMap.put(p, count);</span><br><span class="line">            ans = Math.max(ans, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k != parent[k])&#123;</span><br><span class="line">            parent[k] = find(parent[k], parent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uion</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[] parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = find(i, parent);</span><br><span class="line">        <span class="keyword">int</span> y = find(j, parent);</span><br><span class="line">        <span class="keyword">if</span>(x != y)&#123;</span><br><span class="line">            parent[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-1893. 检查是否区域内所有整数都被覆盖</title>
    <link href="https://liuheng0315.github.io/2021/07/23/leetcode/leetcode-1893-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%8C%BA%E5%9F%9F%E5%86%85%E6%89%80%E6%9C%89%E6%95%B4%E6%95%B0%E9%83%BD%E8%A2%AB%E8%A6%86%E7%9B%96/"/>
    <id>https://liuheng0315.github.io/2021/07/23/leetcode/leetcode-1893-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%8C%BA%E5%9F%9F%E5%86%85%E6%89%80%E6%9C%89%E6%95%B4%E6%95%B0%E9%83%BD%E8%A2%AB%E8%A6%86%E7%9B%96/</id>
    <published>2021-07-23T02:19:57.000Z</published>
    <updated>2021-07-23T02:20:31.200Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1893-检查是否区域内所有整数都被覆盖"><a class="markdownIt-Anchor" href="#1893-检查是否区域内所有整数都被覆盖"></a> <a href="https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/">1893. 检查是否区域内所有整数都被覆盖</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCovered</span><span class="params">(<span class="keyword">int</span>[][] ranges, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] arr : ranges)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> r = arr[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(left &gt;= l &amp;&amp; left&lt;= r)&#123;</span><br><span class="line">                <span class="keyword">if</span>(r &gt;= right)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(isCovered(ranges, r+<span class="number">1</span>, right))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-1049. 最后一块石头的重量 II</title>
    <link href="https://liuheng0315.github.io/2021/07/21/leetcode/leetcode-1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-II/"/>
    <id>https://liuheng0315.github.io/2021/07/21/leetcode/leetcode-1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-II/</id>
    <published>2021-07-21T11:15:28.000Z</published>
    <updated>2021-07-21T11:16:02.183Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1049-最后一块石头的重量-ii"><a class="markdownIt-Anchor" href="#1049-最后一块石头的重量-ii"></a> <a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.length;</span><br><span class="line">        <span class="comment">// 总重量</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum += stones[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 想要返回石头的重量最小，则需要能达到的被摧毁的最大，最理想的结果是为0，假设为0是能达到的情况</span></span><br><span class="line">        <span class="keyword">int</span> neg = sum/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>][neg+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= neg; j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= stones[i-<span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] || dp[i-<span class="number">1</span>][j-stones[i-<span class="number">1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = neg; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[n][j])&#123;</span><br><span class="line">                <span class="keyword">return</span> sum - <span class="number">2</span>*j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-剑指 Offer 52. 两个链表的第一个公共节点</title>
    <link href="https://liuheng0315.github.io/2021/07/21/leetcode/leetcode-%E5%89%91%E6%8C%87-Offer-52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"/>
    <id>https://liuheng0315.github.io/2021/07/21/leetcode/leetcode-%E5%89%91%E6%8C%87-Offer-52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</id>
    <published>2021-07-21T03:16:31.000Z</published>
    <updated>2021-07-21T03:17:03.338Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="剑指-offer-52-两个链表的第一个公共节点"><a class="markdownIt-Anchor" href="#剑指-offer-52-两个链表的第一个公共节点"></a> <a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pA = headA;</span><br><span class="line">        ListNode pB = headB;</span><br><span class="line">        <span class="keyword">while</span>(pA != pB)&#123;</span><br><span class="line">            pA = pA == <span class="keyword">null</span> ? headB : pA.next;</span><br><span class="line">            pB = pB == <span class="keyword">null</span> ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/categories/leetcode/"/>
    
    
    <category term="leetcode" scheme="https://liuheng0315.github.io/tags/leetcode/"/>
    
  </entry>
  
</feed>
